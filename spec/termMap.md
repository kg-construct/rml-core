# 7 Term Maps

An _**RDF term**_ is either an [IRI](), or a [blank node](), or a [literal]().

A [term map]() (`rml:TermMap`)
is a rule that defines how to generate an [RDF term]() from a logical iteration.
The result of that rule is the [RDF term]() which is generated by the .

_**Term maps**_ (`rml:TermMap`) 
are used to generate the subjects, predicates and objects of the [RDF triples]()
that are generated by a [triples map]() (`rml:TriplesMap`).
Consequently, there are several kinds of [term maps]() (`rml:TermMap`),
Depending on where in the mapping they occur, a [Term Map]() (`rml:TermMap`) can be:
* A [Subject Map]() (`rml:SubjectMap`), 
if it is a rule that specifies how the [RDF triple]()'s subject is generated;
* A [predicate map]() (`rml:PredicateMap`),
if it is a rule that specifies how the [RDF triple]()'s predicate is generated;
* A [object map]() (`rml:ObjectMap`),
if it is a rule that specifies how the [RDF triple]()'s object is generated; and
* A [graph map]() (`rml:GraphMap`),
if it is a rule that specifies how the [RDF triple]()'s named graph is generated.

A [Term Map]() should generate different RDF terms
depending on the position of the [Term Map]() in the [RDF triple]():
* A [Subject Map]() (`rml:SubjectMap`)
is a rule that should generate either a [URI]() or a [Blank Node]();
* A [Predicate Map]() (`rml:PredicateMap`)
is a rule that should generate a [URI]();
* An [Object Map]() (`rml:ObjectMap`)
is a rule that should generate a [URI](), a [Blank Node]() or a [Literal]().

A [Term Map]() (`rml:TermMap`) is specified as an [Expression Map]() and MAY have
* one of the [Datatype Map]() and [Language Map](),
which are also specified as [Expression Maps]() and
* a [Term Type]().

## 7.1 Expression Map

An [Expression Map]() (`rml:ExpressionMap`)
is an abstract class, that is specialized by other RML classes.

An [Expression Map]() (`rml:ExpressionMap`) MUST be exactly one of the following:

* a [constant-valued Expression Map](),
* a [reference-valued Expression Map](),
* a [template-valued Expression Map]().

### 7.1.1 Constant Expression Map (rml:constant)

A _**constant-valued Expression Map**_ ignores the logical iteration
and always generates the same [RDF term]().
A [constant-valued Expression Map]() is represented by a resource
that has exactly one `rml:constant` property.

The [constant valued Expression Map]() is the [RDF term]()
that is the value of its `rml:constant` property.

#### Constant-valued Expression Maps and term types

A constant-valued Expression Map generates by default an [RDF Term]() which is an [IRI]().

+++ ADD example +++

If the [constant-valued Expression Map]()
is a [Subject Map](), [Predicate Map]() or [Graph Map](),
then its constant value MUST be an [IRI]().

If the [constant-valued Expression Map]() is an [Object Map](),
then its constant value MUST be an [IRI]() or [literal]().

To overwrite the default term type, one needs to specify the [Term Type]() of the [Term Map]().

+++ ADD example +++

| constant-valued Expression Map | Termtype | RDF Term type generated  |
| :-------------| :-----| :-----|
| Subject Map | `rml:IRI` (default) | `IRI` (default) | 
| Predicate Map | `rml:IRI` (default) | `IRI` (default) |
| Object Map | `rml:IRI` (default) or `rml:Literal` | `IRI` (default) or `Literal` |
| Graph Map | `rml:IRI` (default) |  	`IRI` (default) |

The [reference]() of a [constant-valued]() is the empty set.

#### Shortcuts for constant-valued Expression Maps

[Constant-valued Expression Maps]() can be expressed more concisely
using the _**constant shortcut properties**_
`rml:subject`, `rml:predicate`, `rml:object` and `rml:graph` for the Term Maps, and
`rml:datatype` and `rml:language` fot the [Datatype Map]() and [Language Map]() respectively.
Occurrences of these properties MUST be treated exactly as if
the following triples were present in the mapping graph instead:

| Triple involving constant shortcut property | Replacement triples  |
| :-------------| :-----|
| `?x rml:subject ?y.` | `?x rml:subjectMap [ rml:constant ?y ].` | 
| `?x rml:predicate ?y.` | `?x rml:predicateMap [ rml:constant ?y ].` |
| `?x rml:object ?y.` | `?x rml:objectMap [ rml:constant ?y ].` |
| `?x rml:graph ?y.` |  	`?x rml:graphMap [ rml:constant ?y ].` |
| `?x rml:datatype ?y.` |  	`?x rml:datatypeMap [ rml:constant ?y ].` |
| `?x rml:language ?y.` |  	`?x rml:languageMap [ rml:constant ?y ].` |

+++ ADD example +++

### 7.1.2 Reference (rml:reference)

A _**reference-valued Expression Map**_ is represented by a resource
that has exactly one `rml:reference` property.

The value of the `rml:reference` property MUST be a valid reference
according to the reference formulation specified in the [Logical Source]().
The _**reference value**_ of the [Term Map]() is the data value of that reference
in a given logical iteration.

The [reference]() is the singleton set containing the value of the `rml:reference` property.

#### Reference-valued Expression Maps and term types

A reference-valued [Expression Map]() generates an [RDF Term]()
which is by default a [Literal]().

To use a reference-valued [Expression Map]()
in a [Subject Map]() or [Graph Map](),
which should generate an [RDF Term]()
which is either an [IRI]() or [Literal](), or
a [Predicate Map](),
which should generate an [RDF Term]() which is an [IRI](),
or to generate an [IRI]() for an [Object Map](),
then the default [Term Type]() needs to be overwritten.

+++ ADD example +++

### 7.1.3 From a Template (rml:template)

A [template-valued term map]() is represented by a resource
that has exactly one `rml:template` property.
The value of the `rml:template` property MUST be a valid [string template]().

A _**string template**_ is a format string that can be used
to build strings from multiple components.
It can reference [references]() by enclosing them in curly braces (“{” and “}”).
The following syntax rules apply to valid string templates:

* Pairs of unescaped curly braces MUST enclose valid references.
* Curly braces that do not enclose references MUST be escaped by a backslash character (“\”).
This also applies to curly braces within references.
* Backslash characters (“\”) MUST be escaped by preceding them with another backslash character, yielding “\\”. This also applies to backslashes within column names.
* There SHOULD be at least one pair of unescaped curly braces.
* If a template contains multiple pairs of unescaped curly braces,
then any pair SHOULD be separated from the next one by a _**safe separator**_.
This is any character or string
that does not occur anywhere in any of the data values of either reference;
or in the [IRI-safe versions]() of the data values,
if the [term type]() is `rml:IRI`.

The _**template value**_ of the [term map]() for a given logical iteration
is determined as follows:

1. Let result be the [template string]()
2. For each pair of unescaped curly braces in result:
    1. Let value be the data value of the column whose name is enclosed in the curly braces
    2. If value is NULL, then return NULL
    3. Let value be the [natural RDF lexical form]() corresponding to value
        If the [term type]() is `rml:IRI`,
        then replace the pair of curly braces with an [IRI-safe version]() of value;
        otherwise, replace the pair of curly braces with value
3. Return result

The IRI-safe version of a string is obtained by applying the following transformation
to any character that is not in the iunreserved production in [[RFC3987]]():

1. Convert the character to a sequence of one or more octets using UTF-8 [[RFC3629]]()
2. Percent-encode each octet [[RFC3986]]()

The following table shows examples of strings and their IRI-safe versions:


| String | IRI-safe version  |
| :-------------| :-----|
| 42 | 42 | 
| Hello World! | Hello%20World%21 |
| 2011-08-23T22:17:00Z | 2011-08-23T22%3A17%3A00Z |
| ~A_17.1-2 |  ~A_17.1-2 |

**NOTE**
RML always performs percent-encoding when IRIs are generated from string templates.
If IRIs need to be generated without percent-encoding,
then `rml:reference` should be used instead of `rml:template`,
with a logical data source that performs the string concatenation.

In the case of string templates that generate IRIs,
any single character that is legal in an IRI,
but percent-encoded in the [IRI-safe version]() of a data value, is a safe separator.
This includes in particular the eleven sub-delim characters defined in [[RFC3987]]():
!$&'()*+,;=

The [reference]() of a [template-valued term map]()
is the set of column names enclosed in unescaped curly braces in the [template string]().

The following example defines a [subject map]()
that generates [IRIs]() from ??? of a logical data source.

+++ ADD EXAMPLE +++

Using the sample iteration from ??? as a logical data source,
the template value of the [subject map]() would be:

+++ ADD EXAMPLE +++

The following example shows how an [IRI-safe]() template value is created:

+++ ADD EXAMPLE +++

Using the sample iteration from ??? as a logical data source,
the template value of the [subject map]() would be:

+++ ADD EXAMPLE +++

The space character is not in the iunreserved set,
and therefore percent-encoding is applied to the character, yielding “%20”.

The following example shows the use of backslash escapes in string templates.
The template will generate a fancy title such as

{{{ \o/ Hello World! \o/ }}}

from a string “Hello World!” in the referernce.
By default, `rml:template` generates IRIs.
Since the intention here is to create a literal instead,
the [term type]() has to be set.

+++ ADD EXAMPLE +++


Note that because
[backslashes need to be escaped by a second backslash in the Turtle syntax]() [[TURTLE]],
a double backslash is needed to escape each curly brace,
and to get one literal backslash in the output
one needs to write four backslashes in the template.

## 7.4 IRIs, Literal, Blank Nodes (rml:termType)

The term type of a [column-valued term map] or [template-valued term map]
determines the kind of [generated RDF term]() ([IRIs](), [blank nodes]() or [literals]()).

If the term map has an optional `rml:termType` property,
then its [term type]() is the value of that property.
The value MUST be an [IRI]() and MUST be one of the following options:

* If the term map is a [subject map](): `rml:IRI` or `rml:BlankNode`
* If the term map is a [predicate map](): `rml:IRI`
* If the term map is an [object map](): `rml:IRI`, `rml:BlankNode`, or `rml:Literal`
* If the term map is a [graph map](): `rml:IRI`


If the [term map]() does not have a `rml:termType` property, then its term type is:

* `rml:Literal`, if it is an [object map]()
and at least one of the following conditions is true:
* It is a [column-based term map]().
    * It has a `rml:language` property (and thus a [specified language tag]()).
    * It has a `rml:datatype` property (and thus a [specified datatype]()).
* rml:IRI, otherwise.

**NOTE**

Term maps with term type `rml:IRI` cause [data errors]()
if the value is not a valid IRI (see [generated RDF term]() for details).
Data values from the input database may require percent-encoding
before they can be used in IRIs.
[Template-valued term maps]() are a convenient way of percent-encoding data values.


**NOTE**

[Constant-valued term maps]() are not considered as having a term type,
and specifying `rml:termType` on these [term maps]() has no effect.
The type of the generated [RDF term]() is determined directly by the value of `rml:constant`:
If it is an [IRI](), then an [IRI]() will be generated;
if it is a literal, a literal will be generated.

## 7.5 Language Tags (rml:language)

A [term map]() with a term type of `rml:Literal` MAY have a specified language tag.
It is represented by the `rml:language` property on a [term map]().
If present, its value MUST be a valid language tag.

A specified language tag causes generated literals to be language-tagged plain literals.
In the following example,
plain literals with language tag “en-us” (U.S. English)
will be generated for the data values in the DNAME column.

+++ ADD EXAMPLE +++


## 7.6 Typed Literals (rml:datatype)

A _**datatypeable term map**_ is a term map with a term type of `rml:Literal`
that does not have a [specified language tag]().

Datatypeable term maps may generate [typed literals]().
The datatype of these literals can be automatically determined
based on the SQL datatype of the underlying logical table column
(producing a [natural RDF literal]()),
or it can be explicitly overridden using `rml:datatype`
(producing a [datatype-override RDF literal]()).

A [datatypeable term map]() MAY have a `rml:datatype` property.
Its value MUST be an [IRI](). This [IRI]() is the specified datatype of the [term map]().

A [term map]() MUST NOT have more than one `rml:datatype` value.

A [term map]() that is not a datatypeable term map MUST NOT have an `rml:datatype` property.

See generated [RDF term]() for further details on generating literals from [term maps]().

**NOTE**

One cannot explicitly state that a [plain literal]()
without language tag should be generated.
To generate one from a non-string reference,
a [template-valued term map]() with a template such as "{MY_REFERENCE}"
and a term type of `rml:Literal` can be used.

The following example shows an [object map]()
that explicitly specifies `xsd:positiveInteger` type.
A [datatype-override RDF literal] of that datatype will be generated.

+++ ADD EXAMPLE +++





























