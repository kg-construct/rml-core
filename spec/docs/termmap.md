# Term Maps

An <dfn>RDF term</dfn> is either an [IRI](), or a [blank node](), or a [literal]().

A <dfn>term map</dfn> (`rml:TermMap`) is a rule that defines how to generate an [=RDF term=] from a logical iteration. 
The result of the execution of that rule is the [=RDF term=].

A [=term map=] is a sub-class of an [=expression map=].

[=Term maps=] (`rml:TermMap`) 
are used to generate the subjects, predicates and objects of the [RDF triples]()
that are generated by a [=triples map=] (`rml:TriplesMap`).
Consequently, there are several kinds of [=term maps=] (`rml:TermMap`).
Depending on where in the mapping they occur, a [=term map=] (`rml:TermMap`) can be:
* a [=subject map=] (`rml:SubjectMap`), 
if it is a rule that specifies how the [RDF triple]()'s subject is generated;
* a [=predicate map=] (`rml:PredicateMap`),
if it is a rule that specifies how the [RDF triple]()'s predicate is generated;
* an [=object map=] (`rml:ObjectMap`),
if it is a rule that specifies how the [RDF triple]()'s object is generated; and
* a [=graph map=] (`rml:GraphMap`),
if it is a rule that specifies how the [RDF triple]()'s named graph is generated.

A [=term map=] should generate different RDF terms
depending on the position of the [=term map=] in the [RDF triple]():
* a [=subject map=] (`rml:SubjectMap`)
is a rule that should generate either an [IRI]() or a [Blank Node]();
* a [=predicate map=] (`rml:PredicateMap`)
is a rule that should generate an [IRI]();
* an [=object map=] (`rml:ObjectMap`)
is a rule that should generate an [IRI](), a [Blank Node]() or a [Literal]();
* a [=graph map=] (`rml:GraphMap`)
is a rule that should generate an [IRI]().

A [=term map=] MAY have
* a [=datatype map=] or a [=language map=];
* a [=term type=].


### Constant RDF Terms (`rml:constant`)

A <dfn>constant-valued term map</dfn> is a term map that ignores the [=logical iteration=] and always generates the same [=RDF term=]. A [=constant-valued term map=] is a [=constant-valued expression map=], and is thus represented by a resource that has exactly one `rml:constant` property. The [=constant expression=] MUST be a [valid RDF term](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term).

The [=constant value=] of the `rml:constant` property is the [=RDF term=] that is the result of the execution of the [=term map=].

#### Shortcuts for constant-valued term  maps

[=constant-valued term maps=] can be expressed more concisely
using the <dfn>constant shortcut properties</dfn>
`rml:subject`, `rml:predicate`, `rml:object`, and `rml:graph` for the [=term maps=], and
`rml:datatype` and `rml:language` for the [=datatype map=] and [=language map=] respectively.
Occurrences of these properties MUST be treated exactly as if
the following triples were present in the [=mapping graph=] instead:

| Triple involving constant shortcut property | Replacement triples  |
| :-------------| :-----|
| `?x rml:subject ?y.` | `?x rml:subjectMap [ rml:constant ?y ].` | 
| `?x rml:predicate ?y.` | `?x rml:predicateMap [ rml:constant ?y ].` |
| `?x rml:object ?y.` | `?x rml:objectMap [ rml:constant ?y ].` |
| `?x rml:graph ?y.` | `?x rml:graphMap [ rml:constant ?y ].` |
| `?x rml:datatype ?y.` | `?x rml:datatypeMap [ rml:constant ?y ].` |
| `?x rml:language ?y.` | `?x rml:languageMap [ rml:constant ?y ].` |

### Reference (`rml:reference`)

A <dfn>reference-valued term map</dfn> is a [=reference-valued expression map=], and is thus represented by a resource
that has exactly one `rml:reference` property.

### Template (`rml:template`)

A <dfn>template-valued term map</dfn> is a [=template-valued expression map=], and is thus represented by a resource
that has exactly one `rml:template` property.

The space character is not in the iunreserved set,
and therefore percent-encoding is applied to the character, yielding “%20”.

The following example shows the use of backslash escapes in string templates.
The template will generate a fancy title such as

```
{{{ \o/ Hello World! \o/ }}}
```

from a string “Hello World!” in the referernce.
By default, `rml:template` generates IRIs.
Since the intention here is to create a literal instead,
the [=term type=] has to be set.

Note that because
[backslashes need to be escaped by a second backslash in the Turtle syntax]() [[TURTLE]],
a double backslash is needed to escape each curly brace,
and to get one literal backslash in the output
one needs to write four backslashes in the template.

## IRIs, Literal, Blank Nodes (rml:termType)

The <dfn>term type</dfn> of a [=reference-valued term map=] or [=template-valued term map=]
determines the kind of [=generated RDF term=] ([IRIs](), [blank nodes]() or [literals]()).

If the term map has an optional `rml:termType` property,
then its [=term type=] is the value of that property.
The value MUST be an [IRI]() and MUST be one of the following options:

* If the term map is a [=subject map=]: `rml:IRI` or `rml:BlankNode`
* If the term map is a [=predicate map=]: `rml:IRI`
* If the term map is an [=object map=]: `rml:IRI`, `rml:BlankNode`, or `rml:Literal`
* If the term map is a [=graph map=]: `rml:IRI`

### Default Term Types

If the [=term map=] does not have a `rml:termType` property, then its [=term type=] is:

* `rml:IRI`, if it is a [=subject map=], [=predicate map=] or [=graph map=]
* `rml:Literal`, if it is an [=object map=]
and at least one of the following conditions is true:
* It is a [=reference-valued term map=].
    * It has a `rml:languageMap` property (and thus a [specified language tag]()).
    * It has a `rml:datatypeMap` property (and thus a [specified datatype]()).
* `rml:IRI`, otherwise.

### Explicitly Defined Term Types

To change the default [=term type=] of a [=subject map=] or [=graph map=]
to a blank node, the [=term type=] MUST be explicitly defined to be a `rml:BlankNode`.

To change the default [=term type=] of an [=object map=], the [=term type=] MUST be explicitly defined:
* If the [=term type=] is `rml:IRI`, an IRI will be generated;
* If the [=term type=] is `rml:BlankNode`, a Blank Node will be generated.

If the [=term type=] is explicitly defined to be a `rml:BlankNode`,
a [=term map=] MAY not have an [=expression map=].
Then an RML Processor MUST generate a random value for the blank node.   

### IRI encoding

If the [=term type=] of the [=template-valued term map=] is `rml:IRI`, then a [=reference value transforming function=] should be applied during the evaluation of the [=template expression=]. The [=reference value transforming function=] should transform a [=reference value=] into an [=IRI-safe version=] of that value.

The <dfn data-lt="IRI-safe">IRI-safe version</dfn> of a string is obtained by applying the following transformation
to any character that is not in the iunreserved production in [[RFC3987]]():

1. Convert the character to a sequence of one or more octets using UTF-8 [[RFC3629]]()
2. Percent-encode each octet [[RFC3986]]()

The following table shows examples of strings and their IRI-safe versions:


| String | IRI-safe version  |
| :-------------| :-----|
| 42 | 42 | 
| Hello World! | Hello%20World%21 |
| 2011-08-23T22:17:00Z | 2011-08-23T22%3A17%3A00Z |
| ~A_17.1-2 |  ~A_17.1-2 |

<aside class="note">
RML always performs percent-encoding when IRIs are generated from [=string templates=].
If IRIs need to be generated without percent-encoding,
then `rml:reference` should be used instead of `rml:template`,
with a [=logical source=] that performs the string concatenation.
</aside>

<aside class="note">
Term maps with [=term type=] `rml:IRI` cause [=data errors=]
if the value is not a valid IRI (see [=generated RDF term=] for details).
Data values from the input database may require percent-encoding
before they can be used in IRIs.
[=Template-valued term maps=] are a convenient way of percent-encoding data values.
</aside>

## Language tags (`rml:languageMap` and `rml:language`)

A <dfn>language-taggable term map</dfn> is a [=term map=] with a [=term type=] of `rml:Literal` that does not have a [specified datatype map](#typed-literals-rml-datatypemap-and-rr-datatype).

A [=language-taggable term map=] MAY be associated with a [=language map=].

A <dfn>language map</dfn> (`rml:LanguageMap`) is an [=expression map=]. It specifies a rule for generating one or more [language tags](https://www.w3.org/TR/rdf11-concepts/#dfn-language-tag) for a [=language-taggable term map=]. Following [[rdf11-concepts-20140225]], the generated language tags MUST be well-formed according to [[BCP47]].

Given the list of values resulting from a [=language-taggable term map=] `T`, and the list of values resulting from its [=language map=] `L`, the resulting terms are generated by the [=n-ary Cartesian product=] combination of `T × L`, where the values in `T` are the [lexical forms](https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form), and the values in `L` are the non-empty language tags.

Each combination of `T × L` causes the generation of a language-tagged plain literal.

In the following example the lexical form values generated by reference `"Localization"` are combined with the well-formed language tag values from reference `"Localization[@Culture]"` to generate a list of language tagged literals.

```turtle "example": "usage of language map"
[] rml:objectMap [
  rml:reference "Localization" ;
  rml:languageMap [
    rml:reference "Localization[@Culture]" ;
  ] ;
] .
```

## Typed Literals (`rml:datatypeMap` and `rml:datatype`)

A <dfn>datatypeable term map</dfn> is a [=term map=] with a [=term type=] of `rml:Literal` that does not have a [specified language map](#language-tags-rml-languagemap-and-rr-language).

[=Datatypeable term maps=] MAY generate typed literals. The datatype of these literals MAY be [automatically determined](#automatically-deriving-datatypes), or it MAY be explicitly specified using a [=datatype map=].

A <dfn>datatype map</dfn> (`rml:DatatypeMap`) is an [=expression map=]. It specifies a rule for generating one or more datatypes of a [=datatypeable term map=]. A [=datatype map=] MUST generate a list of IRI values, in which the IRIs are the datatypes of the [=datatypeable term map=].

Given the list of values resulting from a [=datatypeable term map=] `T`, and the list of values resulting from its [=datatype map=] `D`, the resulting terms are generated by the [=n-ary Cartesian product=] combination of `T × D`, where the values in `T` are the literal values, and the values in `D` are the datatype IRIs.

```turtle "example": "usage of datatype map"
[] rml:objectMap [
  rml:reference "value" ;
  rml:datatypeMap [
    rml:template "http://www.w3.org/2001/XMLSchema#{datatype}" ;
  ] ;
] .
```

A [=datatypeable term map=] MUST have zero or one [=datatype maps=], which can be specified in two ways:
1. using the `rml:datatypeMap` property, whose value MUST be a [=datatype map=], or
2. using the [=constant shortcut property=] `rml:datatype`.

A [=term map=] that is not a [=datatypeable term map=] MUST NOT have an `rml:datatypeMap` or `rml:datatype` property.

See [=generated RDF term=] for further details on generating literals from [=term maps=].

<aside class="note">
One cannot explicitly state that a [plain literal]()
without language tag should be generated.
To generate one from a non-string [=reference value=],
a [=template-valued term map=] with a template such as `"{MY_REFERENCE}"`
and a term type of `rml:Literal` can be used.
</aside>

The following example shows an [=object map=]
that explicitly specifies `xsd:positiveInteger` type.
A [datatype-override RDF literal] of that datatype will be generated.

### Automatically deriving datatypes

The datatype of these literals can be automatically determined
based on the SQL datatype of the underlying logical table column
(producing a [natural RDF literal]()),
or it can be explicitly overridden using `rml:datatype`
(producing a [datatype-override RDF literal]()).

<aside class="issue">
This needs work
</aside>

### Term types

#### Reference-valued term maps and term types

A [=reference-valued term map=] generates an [=RDF term=]
which is by default a [Literal]().

If the [=reference-valued term map=] is a [=subject map=], [=predicate map=], or [=graph map=], then its [=constant value=] MUST be an [IRI]().

If the [=reference-valued term map=] is an [=object map=], then its [=constant value=] MUST be a [literal]().

To use a [=reference-valued term map=]
as a [Object Map]() or [Graph Map](),
which should generate an [=RDF term=]
which is either an [IRI]() or [Literal](), or
a [Predicate Map](),
which should generate an [=RDF term=] which is an [IRI](),
or to generate an [IRI]() for an [=object map=],
the default [Term Type]() needs to be overwritten.

#### Constant-valued term maps and term types

If the [=constant-valued term map=] is a [=subject map=], [=predicate map=], or [=graph map=], then its [=constant value=] MUST be an [IRI]().

If the [=constant-valued term map=] is an [=object map=], then its [=constant value=] MUST be an [IRI]() or [literal]().