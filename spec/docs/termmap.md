# Term Maps

An <dfn>RDF term</dfn> is either an [=IRI=], or a [=blank node=], or a [=literal=].

A <dfn>term map</dfn> (`rml:TermMap`) is a rule that defines how to generate an [=RDF term=] from a [=logical iteration=].
The result of the execution of that rule is the <dfn>generated RDF term</dfn>.

A [=term map=] is a sub-class of an [=expression map=].

[=Term maps=] (`rml:TermMap`)
are used to generate the subjects, predicates and objects of the [=RDF triples=]
that are generated by a [=triples map=] (`rml:TriplesMap`).
Consequently, there are several kinds of [=term maps=] (`rml:TermMap`).
Depending on where in the mapping they occur, a [=term map=] (`rml:TermMap`) can be:
* a [=subject map=] (`rml:SubjectMap`),
if it is a rule that specifies how the [=RDF triple=]'s subject is generated;
* a [=predicate map=] (`rml:PredicateMap`),
if it is a rule that specifies how the [=RDF triple=]'s predicate is generated;
* an [=object map=] (`rml:ObjectMap`),
if it is a rule that specifies how the [=RDF triple=]'s object is generated; and
* a [=graph map=] (`rml:GraphMap`),
if it is a rule that specifies how the [=RDF triple=]'s [=named graph=] is generated.

A [=term map=] generates different types of [=RDF terms=] depending on the position of the [=term map=] in the [=RDF triple=]:
* a [=subject map=] (`rml:SubjectMap`)
is a rule that MUST generate either an [=IRI=] or a [=blank node=];
* a [=predicate map=] (`rml:PredicateMap`)
is a rule that MUST generate an [=IRI=];
* an [=object map=] (`rml:ObjectMap`)
is a rule that MUST generate an [=IRI=], a [=blank node=] or a [=literal=];
* a [=graph map=] (`rml:GraphMap`)
is a rule that SHOULD generate an [=IRI=].

A [=term map=] MUST have
* 0 or 1 [=datatype map=] or 0 or 1 [=language map=];
* 0 or 1 [=term type=].


### Constant RDF Terms (`rml:constant`)

A <dfn>constant-valued term map</dfn> is a term map that ignores the [=logical iteration=] and always generates the same [=RDF term=]. A [=constant-valued term map=] is a [=constant-valued expression map=], and is thus represented by a resource that has exactly one `rml:constant` property. The [=constant expression=] MUST be a valid [=RDF term=].

The [=constant value=] of the `rml:constant` property is the [=generated RDF Term=].

#### Shortcuts for constant-valued term  maps

[=Constant-valued term maps=] can be expressed more concisely
using the <dfn>constant shortcut properties</dfn>
`rml:subject`, `rml:predicate`, `rml:object`, and `rml:graph` for the [=term maps=], and
`rml:datatype` and `rml:language` for the [=datatype map=] and [=language map=] respectively.
Occurrences of these properties MUST be treated exactly as if
the following triples were present in the [=mapping graph=] instead:

| Triple involving constant shortcut property | Replacement triples  |
| :-------------| :-----|
| `?x rml:subject ?y.` | `?x rml:subjectMap [ rml:constant ?y ].` |
| `?x rml:predicate ?y.` | `?x rml:predicateMap [ rml:constant ?y ].` |
| `?x rml:object ?y.` | `?x rml:objectMap [ rml:constant ?y ].` |
| `?x rml:graph ?y.` | `?x rml:graphMap [ rml:constant ?y ].` |
| `?x rml:datatype ?y.` | `?x rml:datatypeMap [ rml:constant ?y ].` |
| `?x rml:language ?y.` | `?x rml:languageMap [ rml:constant ?y ].` |

### Reference (`rml:reference`)

A <dfn>reference-valued term map</dfn> is a [=reference-valued expression map=], and is thus represented by a resource that has exactly one `rml:reference` property.

The evaluation of a [=reference-valued expression map=] against a given [=logical iteration=] produces a [=reference value=]. For each value in the list, an [=RDF term=] is created. If the [=reference value=] is an empty list, then there will be no [=generated RDF term=].

<aside class="example" id="example-reference" title="Usage of reference-valued term map">

The following example defines a [=predicate-object map=] that generates [=RDF triples=] with the `ex:keyword` predicate and the `Keywords` value from the `images.json` [=input data source=] from [[[#example-input-data-sources]]].

<aside class="ex-mapping">

```turtle
<#ImageTriplesMap>
  rml:predicateObjectMap [
    rml:predicate ex:keyword ;
    rml:objectMap [
      rml:reference "$.Keywords" ;
    ] ;
  ] .
```

</aside>

Using the [=logical iteration=], the [=reference value=] of the [=object map=] is:

<aside class="ex-output">

```json
["building", "city", "view"]
```

</aside>

The [=RDF triples=] generated by the [=predicate-object map=] are:

<aside class="ex-output">

```turtle
<http://data.example.com/image/116> ex:keyword "building" .
<http://data.example.com/image/116> ex:keyword "city" .
<http://data.example.com/image/116> ex:keyword "view" .
```

</aside>

</aside>

### Template (`rml:template`)

A <dfn>template-valued term map</dfn> is a [=template-valued expression map=], and is thus represented by a resource
that has exactly one `rml:template` property.

If the [=template value=] returned by the [=template-valued expression map=] is an empty list, no RDF term will be created.

#### IRI encoding

If the [=term type=] of the [=template-valued term map=] is `rml:IRI`, then a [=reference value transforming function=] MUST be applied during the evaluation of the [=template expression=]. The [=reference value transforming function=] MUST transform a [=reference value=] into an [=IRI-safe version=] of that value.

The <dfn data-lt="IRI-safe">IRI-safe version</dfn> of a string is obtained by applying the following transformation
to any character that is not in the [`iunreserved` production](http://tools.ietf.org/html/rfc3987#section-2.2) in [[RFC3987]]:

1. Convert the character to a sequence of one or more octets using [UTF-8](http://tools.ietf.org/html/rfc3629) [[RFC3629]]
2. [Percent-encode](http://tools.ietf.org/html/rfc3986#section-2.1) each octet [[RFC3986]]

The following table shows examples of strings and their IRI-safe versions:


| String | IRI-safe version  |
| :-------------| :-----|
| 42 | 42 |
| Hello World! | Hello%20World%21 |
| 2011-08-23T22:17:00Z | 2011-08-23T22%3A17%3A00Z |
| ~A_17.1-2 |  ~A_17.1-2 |

<aside class="note">
RML always performs percent-encoding when [=IRIs=] are generated from [=string templates=].
If [=IRIs=] need to be generated without percent-encoding, then `rml:reference` should be used instead of `rml:template`, with a [=logical source=] that performs the string concatenation.
</aside>

<aside class="note">
Term maps with [=term type=] `rml:IRI` cause [=data errors=] if the value is not a valid [=IRI=] (see [=generated RDF term=] for details).
Data values from the input database may require percent-encoding before they can be used in [=IRIs=].
[=Template-valued term maps=] are a convenient way of percent-encoding data values.
</aside>

<aside class="example" id="example-template" title="Usage of template-valued term map">

The following example defines a [=subject map=] that generates [=IRIs=] from the `ID` of the `images.json` [=input data source=] from [[[#example-input-data-sources]]].

<aside class="ex-mapping">

```turtle
<#ImageTriplesMap>
  rml:subjectMap [
    rml:template "http://data.example.com/image/{$.ID}" ;
  ] .
```

</aside>

Using the [=logical iteration=], the [=template value=] of the [=subject map=] would be:

<aside class="ex-output">

```turtle
<http://data.example.com/image/116>
```

</aside>

</aside>

<aside class="example" id="example-template-iri-safe" title="IRI-safe template values">

The following example shows how an [=IRI-safe=] template value is created.
Here the `album.json` [=input data source=] is used to generate an [=IRI=] using the `Author` name.

<aside class="ex-mapping">

```turtle
<#AuthorTriplesMap>
  rml:subjectMap [
    rml:template "http://data.example.com/author/{$.Author}" ;
  ] .
```

</aside>

Using the [=logical iteration=], the [=template value=] of the [=subject map=] would be:

<aside class="ex-output">

```turtle
<http://data.example.com/author/John%20Doe>
```

</aside>

The space character is not in the [`iunreserved` production](http://tools.ietf.org/html/rfc3987#section-2.2), and therefore percent-encoding is applied to the character, yielding "`%20`".

</aside>

<aside class="example" id="example-template-backslash-escape" title="Backslash escapes in templates">

The following example shows the use of backslash escapes in string templates. The template will generate a fancy title such as

<aside class="ex-output">

```turtle
"{{{ \o/ Hello World! \o/ }}}"
```

</aside>

from a string "Hello World!" in the `Title` reference. By default, `rml:template` generates [=IRIs=]. Since the intention here is to create a [=literal=] instead, the [=term type=] has to be set.

<aside class="ex-mapping">

```turtle
<#TriplesMap>
  rml:objectMap [
    rml:template "\\{\\{\\{ \\\\o/ {Title} \\\\o/ \\}\\}\\}" ;
    rml:termType rml:Literal ;
  ] .
```

</aside>

Note that because
[backslashes need to be escaped by a second backslash in the Turtle syntax](https://www.w3.org/TR/turtle/#string) [[TURTLE]], a double backslash is needed to escape each curly brace, and to get one literal backslash in the output one needs to write four backslashes in the template.

</aside>

## IRIs, Literal, Blank Nodes (rml:termType)

The <dfn>term type</dfn> of a [=reference-valued term map=] or [=template-valued term map=]
determines the kind of [=generated RDF term=] ([=IRIs=], [=blank nodes=] or [=literals=]).

If the term map has an optional `rml:termType` property,
then its [=term type=] is the value of that property.
The value MUST be an [=IRI=] and MUST be one of the following options:

* If the term map is a [=subject map=]: `rml:IRI` or `rml:BlankNode`
* If the term map is a [=predicate map=]: `rml:IRI`
* If the term map is an [=object map=]: `rml:IRI`, `rml:BlankNode`, or `rml:Literal`
* If the term map is a [=graph map=]: `rml:IRI`

### Default Term Types

If the [=term map=] does not have a `rml:termType` property, then its [=term type=] is:

* `rml:IRI`, if it is a [=subject map=], [=predicate map=] or [=graph map=]
* `rml:Literal`, if it is an [=object map=]
and at least one of the following conditions is true:
* It is a [=reference-valued term map=].
    * It has a `rml:languageMap` property (and thus a specified [=language tag=]).
    * It has a `rml:datatypeMap` property (and thus a specified [=datatype=]).
* `rml:IRI`, otherwise.

### Explicitly Defined Term Types

To change the default [=term type=] of a [=subject map=] or [=graph map=]
to a [=blank node=], the [=term type=] MUST be explicitly defined to be a `rml:BlankNode`.

To change the default [=term type=] of an [=object map=], the [=term type=] MUST be explicitly defined:
* If the [=term type=] is `rml:IRI`, an [=IRI=] will be generated;
* If the [=term type=] is `rml:BlankNode`, a [=blank node=] will be generated.

If the [=term type=] is explicitly defined to be a `rml:BlankNode`,
a [=term map=] MAY not have an [=expression map=].
Then an RML Processor MUST generate a random value for the [=blank node=].

<aside class="note">
[=Term maps=] with [=term type=] `rml:IRI` cause [=data errors=] if the value is not a valid [=IRI=] (see [=generated RDF term=] for details).
Data values from the logical source may require percent-encoding before they can be used in [=IRIs=].
[=Template-valued term maps=] are a convenient way of percent-encoding data values.
</aside>

<aside class="note">
[=Constant-valued term maps=] are not considered as having a term type, and specifying `rml:termType` on these [=term maps=] has no effect.
The type of the [=generated RDF term=] is determined directly by the value of `rml:constant`: If it is an [=IRI=], then an [=IRI=] will be generated; if it is a [=literal=], a [=literal=] will be generated.
</aside>

## Language tags (`rml:languageMap` and `rml:language`)

A <dfn>language-taggable term map</dfn> is a [=term map=] with a [=term type=] of `rml:Literal` that does not have a specified [=datatype map=].

A [=language-taggable term map=] MAY be associated with a [=language map=].

A <dfn>language map</dfn> (`rml:LanguageMap`) is an [=expression map=]. It specifies a rule for generating one or more [=language tags=] for a [=language-taggable term map=]. Following [[rdf11-concepts-20140225]], the generated [=language tags=] MUST be well-formed according to [[BCP47]].

Given the list of values resulting from a [=language-taggable term map=] `T`, and the list of values resulting from its [=language map=] `L`, the resulting terms are generated by the [=n-ary Cartesian product=] combination of `T × L`, where the values in `T` are the [=lexical forms=], and the values in `L` are the non-empty [=language tags=].

Each combination of `T × L` causes the generation of a [=language-tagged string=].

<aside class="example" id="example-language-map" title="usage of language map">

In the following example the [=lexical form=] values generated by reference `"Title.value"` are combined with the well-formed [=language tag=] values from reference `"Title.lang"` on the `images.json` [=input data source=] from [[[#example-input-data-sources]]] to generate a output with a [=language-tagged string=].

<aside class="ex-mapping">

```turtle
<#ImageTriplesMap>
  rml:predicateObjectMap [
    rml:predicate ex:title ;
    rml:objectMap [
      rml:reference "$.Title.Value" ;
      rml:languageMap [
        rml:reference "$.Title.Lang" ;
      ] ;
    ] ;
  ] .
```

</aside>

This creates the following [=RDF triples=].

<aside class="ex-output">

```turtle
<http://data.example.com/image/116> ex:title "View from 15th Floor"@en .
```

</aside>

</aside>

## Datatypes of Literals (`rml:datatypeMap` and `rml:datatype`)

A <dfn>datatypeable term map</dfn> is a [=term map=] with a [=term type=] of `rml:Literal` that does not have a [specified language map](#language-tags-rml-languagemap-and-rml-language).

[=Datatypeable term maps=] MUST generate zero or more [=literals=]. The [=datatype=] of these [=literals=] can be automatically determined with a [=natural mapping=] (producing a [=natural RDF literal=]), or it can be explicitly specified using a [=datatype map=] (producing a [=datatype-override RDF literal=]).

A <dfn>datatype map</dfn> (`rml:DatatypeMap`) is an [=expression map=]. It specifies a rule for generating one or more [=datatypes=] of a [=datatypeable term map=]. A [=datatype map=] MUST generate a list of [=IRI=] values, in which the [=IRIs=] are the [=datatype IRIs=] of the [=datatypeable term map=].

Given the list of values resulting from a [=datatypeable term map=] `T`, and the list of values resulting from its [=datatype map=] `D`, the resulting terms are generated by the [=n-ary Cartesian product=] combination of `T × D`, where the values in `T` are the [=literal=] values, and the values in `D` are the [=datatype IRIs=].

<aside class="example" id="example-datatype-map" title="usage of datatype map">

In the following example the [=literal=] values generated by reference `"CreatedDate"` are combined with the [=datatype=] values from the template with the `DateFormat` reference to generate a [=datatype-override RDF literal=].

<aside class="ex-mapping">

```turtle
<#ImageTriplesMap>
  rml:predicateObjectMap [
    rml:predicate ex:createdOn ;
    rml:objectMap [
      rml:reference "$.CreatedDate" ;
      rml:datatypeMap [
        rml:template "http://www.w3.org/2001/XMLSchema#{$.DateFormat}" ;
      ] ;
    ] ;
  ] ;
```

</aside>

This creates the following [=RDF triples=].

<aside class="ex-output">

```turtle
<http://data.example.com/image/116> ex:createdOn "2023-10-01"^^xsd:date .
```

</aside>

</aside>

A [=datatypeable term map=] MUST have zero or one [=datatype maps=], which can be specified in two ways:
1. using the `rml:datatypeMap` property, whose value MUST be a [=datatype map=], or
2. using the [=constant shortcut property=] `rml:datatype`.

A [=term map=] that is not a [=datatypeable term map=] MUST NOT have an `rml:datatypeMap` or `rml:datatype` property.

See [=generated RDF term=] for further details on generating [=literals=] from [=term maps=].

<aside class="note">
One cannot explicitly state that a [=literal=] without [=language tag=] should be generated.
To generate one from a non-string [=reference value=],
a [=template-valued term map=] with a template such as `"{MY_REFERENCE}"`
and a term type of `rml:Literal` can be used.
</aside>

<aside class="example" id="example-datatype-override" title="datatype override">
The following example shows a [=predicate-object map=] with an [=object map=]
that explicitly specifies `xsd:positiveInteger` type.
A [=datatype-override RDF literal=] of that [=datatype=] will be generated when applied to the `images.json` [=input data source=] from [[[#example-input-data-sources]]].

<aside class="ex-mapping">

```turtle
<#ImageTriplesMap>
  rml:predicateObjectMap [
    rml:predicate ex:id ;
    rml:objectMap [
      rml:reference "$.ID" ;
      rml:datatype xsd:positiveInteger ;
    ] ;
  ] ;
```

</aside>

This creates the following [=RDF triples=].

<aside class="ex-output">

```turtle
<http://data.example.com/image/116> ex:id "116"^^xsd:positiveInteger .
```

</aside>

</aside>
